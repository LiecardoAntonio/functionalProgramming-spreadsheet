FCC Functional Programming - Spreadsheet

CONTENT:
1. global window object
  > The global window object represents the browser window (or tab).

2. onload property on window object
  > has an onload property which allows you to define behavior when the window has loaded the entire page, including stylesheets and scripts.
  > ex:
  window.onload = () => {
    const container = document.getElementById('container');
  }

3. (CONCEPT) nested function
  > When a function itself needs to reuse logic, you can declare a nested function to handle that logic.
  > ex:
  const outer = () => {
    const inner = () => {

    };
  };

4. (RECALL) document.createElement('element_tag')
  > Remember that the document object has a .createElement() method which allows you to dynamically create new HTML elements.
  > ex:
  const label = document.createElement('div');

5. (RECALL) element.className = 'class_name'
  > The className property of the Element interface gets and sets the value of the class attribute of the specified element.
  > This property gets or sets the entire class attribute of an element as a single string.
  > If you want to add a new class to an element without removing the existing ones, you would need to manually concatenate the current classes.
  ex: 
  element.className += " another-class";  // Adds a new class while keeping the existing ones

6. (RECALL) element.classList.add('class_name');
  > This method is part of the classList API and allows you to add one or more classes to an element without affecting existing classes.
  > ex:
  element.classList.add("class1", "class2");

7. (RECALL) element.appendChild('other_element');
  > The element.appendChild() method is used to add a node (typically an element) as the last child of a specified parent element. It is part of the DOM (Document Object Model) API in JavaScript.
  > ex:
  const parentDiv = document.getElementById("parent-div");
  const newParagraph = document.createElement("p");
  newParagraph.textContent = "This is a new paragraph!";
  parentDiv.appendChild(newParagraph);

8. Array() constructor
  > The Array() constructor in JavaScript is used to create an array object. It can be invoked in several ways, depending on the number and types of arguments passed to it.
  > Use the Array() constructor create an empty array.
  > ex:
  let arr = new Array(5); 
  console.log(arr);  // [ <5 empty items> ]
  console.log(arr.length);  // 5
  > ex2: 
  let arr = new Array(1, 2, 3);
  console.log(arr);  // [1, 2, 3]

9. Array().fill()
  > The Array.prototype.fill() method in JavaScript is used to fill all the elements of an array with a specified value. It can also optionally accept a start and end index to fill only a portion of the array.
  > template:
  arr.fill(value[, start[, end]])
  /*
    value: The value to fill the array with.
    start (optional): The index at which to start filling (default is 0).
    end (optional): The index at which to stop filling (default is arr.length).
  */
  > ex:
  let arr = new Array(5).fill(0);
  console.log(arr);  // [0, 0, 0, 0, 0]

10. Array().fill().map()
  > Combining Array().fill() with Array.prototype.map() is a common pattern in JavaScript when you want to initialize an array with dynamic values.
  > ex:
  let squares = new Array(5).fill().map((_, i) => i * i);
  console.log(squares);   

11. string.charCodeAt('index')
  > The .charCodeAt() method in JavaScript is used to return the Unicode (UTF-16) code unit of the character at a specified index in a string. This method can be useful when you want to obtain the numeric representation of a character.
  > ex:
  let str = "Hello";
  let code = str.charCodeAt(0);  // Gets the char code of the first character 'H'
  console.log(code);  // 72

12. String.fromCharCode()
  > String.fromCharCode() is a JavaScript method that converts one or more Unicode values (UTF-16 code units) into a string. It is the opposite of the .charCodeAt() method, which retrieves the Unicode code unit of a character from a string.
  > ex:
  let char = String.fromCharCode(72);  // Unicode for 'H'
  console.log(char);  // 'H'

13. (RECALL) element.setAttribute('attribute_name', 'attribute_value')
  > The element.setAttribute() method in JavaScript is used to add a new attribute or change the value of an existing attribute on a specified HTML element. This method is useful when you need to dynamically manipulate attributes such as id, class, src, href, alt, and others in your DOM elements.
  > ex:
  element.setAttribute(name, value);
  > ex2:
  let img = document.querySelector("img");
  img.setAttribute("src", "new-image.jpg");  // Changes the image source
  > we can also write the attribute_name as the property of the element. for example:
  element.id = 'id_name';

14. (RECALL) array.reduce((element, accumulator) => {el+acc}, 0);
  > The Array.prototype.reduce() method in JavaScript is used to apply a function to each element of an array (from left to right) in order to reduce the array to a single output value. It accumulates the result based on the logic you provide in the callback function.
  > ex:
  const sum = (nums) => nums.reduce((el, acc) => acc+el, 0); //sum every element to the accumulator and return the result, initial value is 0

15. (RECALL) array.sort((a, b) => a-b);
  > sort from smallest to highest

16. (RECALL) array.slice()
  > array.slice() creates a shallow copy of the nums array. This means that it returns a new array that contains the same elements as nums. Importantly, this operation does not modify the original nums array. This is useful when you want to sort an array without altering the original data.
  > ex:
  let original = ['a', 'b', 'c'];
  let copy = original.slice();  // Creates a new array
  console.log(copy);  // ['a', 'b', 'c']
  console.log(original === copy);  // false (different references)
  > NOTE: this kinda works the same as the spread operator
  code:
  let original = ['a', 'b', 'c'];
  let copy = ...original;  // Creates a new array

17. (CONCEPT) Declaring object literal
  >  You can use shorthand property names when declaring an object literal. When using the shorthand property name syntax, the name of the variable becomes the property key and its value the property value.
  > ex:
  const userId = 1;
  const firstName = "John";
  const loggedIn = true;

  const user = {
    userId,
    firstName,
    loggedIn,
  };

  console.log(user); // { userId: 1, firstName: 'John', loggedIn: true }

18. string.startsWith('char')
  > check if a string startsWith a specified char, return true if yes

19. string.charAt(index)
  > return the char at specified index of the string.

20. (RECALL) array.find(() => {})
  > The .find(() => {}) method in JavaScript is typically used on arrays to find the first element that matches a specific condition provided in a callback function. It returns the value of the first matching element, or undefined if no match is found.
  > ex:
  const array = [1, 2, 3, 4, 5];

  // Find the first element greater than 3
  const result = array.find((element) => {
      return element > 3;
  });

  console.log(result); // Output: 4

21. (CONCEPT) currying
  > The concept of returning a function within a function is called currying. This approach allows you to create a variable that holds a function to be called later, but with a reference to the parameters of the outer function call.
  > ex:
  const innerOne = elemValue(1);
  const final = innerOne("A");
  // innerOne would be your inner function, with num set to 1, and final would have the value of the cell with the id of "A1". This is possible because functions have access to all variables declared at their creation. This is called closure.
  > ex:
  function add(a) {
      return function(b) {
          return a + b;
      };
  }

  const addTwo = add(2); // Returns a function that adds 2 to its argument
  console.log(addTwo(3)); // Output: 5
  > explanation: The add function is now broken into two functions. The first function takes a and returns a second function that takes b. The second function performs the actual addition.
  > currying in arrow function. ex:
  const multiply = a => b => c => a * b * c;
  console.log(multiply(2)(3)(4)); // Output: 24

22. (DEFINITION) closure
  > A closure in JavaScript is a function that "remembers" its lexical scope, even when the function is executed outside that scope. In simpler terms, a closure allows a function to access variables from its outer (enclosing) function's scope, even after the outer function has finished executing.
  > basic ex:
  function outer() {
      const outerVar = 'I am from the outer function';

      function inner() {
          console.log(outerVar); // The inner function can access outerVar
      }

      return inner;
  }

  const closureFunc = outer(); // outer() returns the inner function
  closureFunc(); // Output: "I am from the outer function"

23. (CONCEPT) currying arrow function
  > Because you are using arrow syntax, you can implicitly return a function using currying concept.
  > ex:
  const curry = soup => veggies => {}; //curry is a function which takes a soup parameter and returns a function which takes a veggies parameter. Using this syntax, update your addCharacters function to return an empty function which takes a character2 parameter.

24. (CONCEPT) function reference  
  > In JavaScript, a function reference refers to the ability to refer to a function by its name without executing it. This allows you to pass the function as an argument, return it from another function, or store it in a variable.
  > ex:
  function sayHello() {
      console.log("Hello!");
  }
  const sayGoodbye = function() {
      console.log("Goodbye!");
  };
  function executeFunction(fn) {
      fn(); // Calls the passed function
  }

  executeFunction(sayHello); // Output: "Hello!"
  executeFunction(sayGoodbye); // Output: "Goodbye!"
  > You can pass a function reference as a callback parameter. A function reference is a function name without the parentheses. 
  > ex:
  const myFunc = (val) => `value: ${val}`;
  const array = [1, 2, 3];
  const newArray = array.map(myFunc);
  //The .map() method here will call the myFunc function, passing the same arguments that a .map() callback takes. The first argument is the value of the array at the current iteration, so newArray would be [value: 1, value: 2, value: 3].

25. (CONCEPT) Immediately Invoked Function Expression (IIFE)
  > JavaScript function that is executed right after it is defined. This is useful for creating a new scope, avoiding variable hoisting issues, and executing code without polluting the global namespace.
  > ex:
  var counter = (function() {
      let count = 0; // private variable

      return {
          increment: function() {
              count++;
              return count;
          },
          decrement: function() {
              count--;
              return count;
          },
          getCount: function() {
              return count;
          }
      };
  })();

  console.log(counter.increment()); // Output: 1
  console.log(counter.increment()); // Output: 2
  console.log(counter.getCount());  // Output: 2

26. (CONCEPT) unused parameter
  > In JavaScript, it is common convention to prefix an unused parameter with an underscore _. 
  > ex:
  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));













